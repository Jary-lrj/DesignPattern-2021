# 软件设计模式项目文档

[TOC]

## 1.总体介绍



### 1.1 组员构成

组长：1953617 李睿捷

成员：1950698 陆天宇

​			1952522 张峰

​			1852461 莫海洋

​			1953081 张福泰

​			1952815 余林旭

​			1953069 闫书玮

​			1953910 李林洲

​			1853629 席宇琛



### 1.2 项目概要

本项目选题为天猫购物节，运用C++的面向对象程序设计，运用23个核心设计模式以及课外学习的部分设计模式，模拟了从用户注册、登录、浏览店铺、浏览商品、浏览广告和活动、操作购物车、生成订单并支付以及商家对店铺、货物进行管理等一系列的场景。



## 2.设计模式介绍

本部分将分别介绍所实现的子系统以及其中所运用到设计模式的详细信息。

### 2.1 顾客子系统 Customer

作用与功能：

设计模式：1）xxx - 说明与类图

2）xxx - 说明与类图

核心代码：

### 2.2 店铺子系统 Shop



### 2.3 商品 Commodity

#### 桥接模式（Bridge）

##### 类图

<img src="img/Bridge.png" width=700>

##### 详述

在商品子系统中，获得商品信息的功能使用了桥接模式，使得商品类的具体实现与其抽象功能分离，二者可以互不干扰地独立变化。

`CommodityInformation`是商品具体实现的基类，它只含有一些最基本的商品信息，比如商品名称，商品ID等。`SingleCommodity`是商品信息基类的一个实现，表示普通的单件商品，它有其特有的属性`amount`即库存。`CompositeCommodity`是商品信息基类的另一个实现，表示复合商品，他也有特有属性`commodity_list`来存储其复合了哪些其他商品。

`CommodityInformationReader`是获取商品属性这一抽象功能的基类，它只有一些基本的方法函数，比如获取商品名称，获取商品价格等。`CommodityInformationVipReader`继承于这个基类，它针对于VIP用户，其`getPrice()`这个方法获取的商品价格是原价的八折。

商品实体基类可以派生出多种复杂的商品具体实现，而商品功能基类也可以派生出多样的方法，两边仅通过基类之间的友元关系“桥接”在一起，使得两种类型的类可被结构化改变而互不影响。

##### 实现API

- `CommodityInformationReader::getPrice():int`，获得商品价格。
- `CommodityInformationReader::getName():string`，获得商品名称。
- `CommodityInformationReader::getID():int`，获得商品ID。
- `CommodityInformationReader::getType():string`，获得商品类型。
- `CommodityInformationReader::getShop():Shop*`，获得商品的商铺。
- `CommodityInformationVipReader::getPrice():int`，VIP用户获得商品价格（打八折）。
- `CommodityInformationVipReader::getName():string`，VIP用户获得商品名称。
- `CommodityInformationVipReader::getID():int`，VIP用户获得商品ID。
- `CommodityInformationVipReader::getType():string`，VIP用户获得商品类型。
- `CommodityInformationVipReader::getShop():Shop*`，VIP用户获得商品的商铺。

#### 组合模式（Composite）

##### 类图

<img src="img/Composite.png" width=600>

##### 详述

组合模式用于把一组相似的对象当作一个单一的对象，依据树形结构来组合对象，用来表示部分以及整体层次。

`CommodityInformation`是商品基类，派生出来`SingleCommodity`单一商品类以及`CompositeCommodity`组合商品类。单一商品类特有属性`amount`表示库存，复合商品类特有属性`commodity_list`存储指向商品基类的指针。商品基类既作为所有商品的统一接口，也作为聚合的对象存在于复合商品类的属性中，从而实现组合模式。

##### 实现API

- `CommodityInfomationSetter::setName(string):void`，设置商品名称。
- `CommodityInfomationSetter::setID(int):void`，设置商品ID。
- `CommodityInfomationSetter::setType(string):void`，设置商品类型。
- `CommodityInfomationSetter::setPrice(int):void`，设置商品价格。
- `CommodityInfomationSetter::addCommodity(CommodityInformation*):bool`，向组合商品中添加商品，如果调用者为单一商品类，则返回`false`。
- `CommodityInfomationSetter::removeCommodity(CommodityInformation*):bool`，删除组合商品中的某件商品，如果调用者为单一商品类，则返回`false`。

#### 迭代器模式（Iterator）

##### 类图

<img src="img/Iterator.png" width=700>

##### 详述

`CompositeCommodityIterator`复合商品迭代器继承于STL中的`iterator<iterator_tag, T>`虚基类，重载了赋值、自加、等于等操作符，使得编写代码时可以轻易使用迭代器遍历复合商品中的所有商品。

##### 实现API

- `CompositeCommodityIterator::opteraor=(CompositeCommodityIterator&)`，迭代器赋值。
- `CompositeCommodityIterator::opteraor==(CompositeCommodityIterator&)`，迭代器等于判断。
- `CompositeCommodityIterator::opteraor!=(CompositeCommodityIterator&)`，迭代器不等于判断。
- `CompositeCommodityIterator::operator++()`，迭代器自加。
- `CompositeCommodityIterator::operator*()`，迭代器取值。
- `CompositeCommodity::begin()`，获取复合商品的第一个元素的迭代器。
- `CompositeCommodity::end()`，获取复合商品的最后一个元素的迭代器。

#### 享元模式（Flyweight）

##### 类图

<img src="img/Flyweight.png" width=600>

##### 关键代码

```c++
/*
 * Flyweight设计模式
 *      工厂在生成对象的时候优先检查哈希表里有没有，有的话直接调用该对象，没有的话再重新生成。
 *      可以大大减少内存的使用，提高运行效率。
 */
CommodityInformation * CommodityFactory::getSingleCommodity(int ID, string name, int price, int shopID, int amount) {
    for (auto iter:_existingCommodityList) {
        reader.setCommodityInformation(iter.first);
        if (reader.getID() == ID)
            return iter.first;
        else
            continue;
    }
    SingleCommodity *singleCommodity = new SingleCommodity(ID, name, price, shopID, amount);
    _existingCommodityList[singleCommodity]++;
    return singleCommodity;
}
```

##### 详述

在`CommodityFactory`商品工厂类中添加属性`_existingCommodityList`，它保存了所有商品的指针以及对应的商品ID，数据结构使用了`std::map`，它的查找时间复杂度为$log{n}$，提高运行效率。在每次构造商品之前，首先遍历`_existingCommodityList`，如果需要构造的商品ID已经存在，则直接返回这个已经存在的商品，不存在的情况下才调用构造函数生成`SingleCommodity`单件商品。从而减少应用的空间使用。

##### 实现API

`getSingleCommodity(int ID, string name, int price, int shopID, int amount):CommodityInformation*`，构造新商品。

#### 命令模式（Command）

##### 类图

<img src="img/Command.png" width=700>

##### 详述

`Command`为命令的虚基类，成员为一个`execute()`纯虚函数。`CommoditySale`类具体功能是卖出一定数量的某件商品。它承并实现了`Command`类，并且聚合了`CommodityInformation`类，表示这个命令类控制的哪件商品。

<img src="img/CommoditySale.png" width=700>

复合商品售卖流程：`CommoditySale`命令类调用`CommodityInformation`商品基类的虚函数`Sell()`，这个函数在复合商品类`CompositeCommodity`复合商品类中实现，它使用迭代器依次调用`SingleCommodity`单件商品类的`IfEnough()`方法，如果所有单件商品的库存都充足，则调用`Sale()`方法依次将商品卖出，并返回`true`，否则返回`false`。

##### 实现API

- `CommoditySale::execute()`，商品售卖命令。
- `CommodityDisplay::execute()`，商品展示命令（复合商品会依次展示其中包含的单件商品）。

### 2.4 活动与广告 Activity & Advertisement



### 2.5 购物车系统 Cart



### 2.6 订单系统 Order



### 2.7 商家系统 Seller

### 

## 3. 补充说明

待定